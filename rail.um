
import (
	"th.um"
)

type Tile* = struct {
	parent: int
	index: int
	rotation: int
	pos: th.Vf2
}

// Switch is multiple segments ending in one place. Even signal is a switch,
// but with only two segments.
type Switch* = struct {
	segs: []int
	// which end of respective segment is part of the switch
	ends: []int
	pos: th.Vf2
	index: int
}

type Segment* = struct {
	swis: [2]int
	tiles: []Tile
	index: int
}

type System* = struct {
	swisMap: [][]^Switch
	tiles: [][]^Tile
	swis: []Switch
	segs: []Segment
}

fn (s: ^System) reset*() {
	for i, l in s.tiles {
		for j, _ in l {
			s.tiles[i][j] = null
		}
	}

	for i, l in s.swisMap {
		for j, _ in l {
			s.swisMap[i][j] = null
		}
	}

	s.swis = []Switch{}
	s.segs = []Segment{}
}

fn (s: ^Segment) connect*(sw: ^Switch, side: int) {
	s.swis[side] = sw.index

	sw.segs = append(sw.segs, s.index)
	sw.ends = append(sw.ends, side)
}

// replaces `tile` by a switch connecting both sides of the segment and returns
// the new switch or null. if tile is the start or end, it doesn't replace it
fn (s: ^Segment) splitAt*(sys: ^System, tile: int): ^Switch {
	if tile > len(s.tiles) { return null }
	if tile == 0 { return &sys.swis[s.swis[0]] }
	if tile == len(s.tiles) - 1 { return &sys.swis[s.swis[1]] }

	// add the switch and init it
	sys.swis = append(sys.swis, Switch{})
	sw := &sys.swis[len(sys.swis) - 1]
	sw.segs = make([]int, 2)
	sw.ends = make([]int, 2)
	sw.pos = s.tiles[tile].pos

	// add the segment
	sys.segs = append(sys.segs, Segment{})
	sg := &sys.segs[len(sys.segs) - 1]

	// set tile arrays
	sg.tiles = slice(s.tiles, tile + 1)
	s.tiles = slice(s.tiles, 0, tile)

	// set inding switches
	sg.swis[0] = len(sys.segs) - 1
	sg.swis[1] = s.swis[1]
	s.swis[1] = sg.swis[0]

	// set switch data
	sw.segs[0] = s.index
	sw.segs[1] = sg.index
	sw.ends[0] = 1
	sw.ends[1] = 0

	return sw
}

fn (sys: ^System) mkSwitch(pos: th.Vf2): ^Switch {
	sys.swis = append(sys.swis, Switch{})
	sw := &sys.swis[len(sys.swis) - 1]
	sw.segs = []int{}
	sw.ends = []int{}
	sw.pos = pos
	sw.index = len(sys.swis) - 1
}

fn (sys: ^System) mkSegment(): ^Segment {
	sys.segs = append(sys.segs, Segment{})
	sg := &sys.segs[len(sys.segs)- 1]
	sg.index = len(sys.segs) - 1
	return sg
}

// places tiles onto map. automatically creates segments and connects them
// to a switch if the tiles pass through it.
fn (sys: ^System)	placeTiles*(tiles: []Tile) {
	sg := sys.mkSegment

	sg.tiles = slice(tiles, 1)
	if sw := sys.swisMap[tiles[0].pos.x][tiles[0].pos.y]; sw != null {
		sg.connect(sw, 0)
	} else {
		sg.connect(sys.mkSwitch(tiles[0].pos), 0)
	}

	last := 1
	for i:=1; i < len(tiles); i++ {
		t := tiles[i]
		if sw := sys.swisMap[t.pos.x][t.pos.y]; sw != null {
			sg.connect(sw, 1)
			sg.tiles = slice(tiles, last, i)	
		}
	}
}
