
import (
	"th.um"
)

type Tile* = struct {
	parent: int
	index: int
	rotation: int
	pos: th.Vf2
}

// Switch is multiple segments ending in one place. Even signal is a switch,
// but with only two segments.
type Switch* = struct {
	segs: []int
	// which end of respective segment is part of the switch
	ends: []int
	pos: th.Vf2
}

type Segment* = struct {
	swis: [2]int
	tiles: []Tile
	index: int
}

type System* = struct {
	tiles: [][]^Tile
	swis: []Switch
	segs: []Segment
}

fn (s: ^System) reset*() {
	for i, l in s.tiles {
		for j, _ in l {
			s.tiles[i][j] = null
		}
	}

	s.swis = []Switch{}
	s.segs = []Segment{}
}

// replaces `tile` by a switch connecting both sides of the segment and returns
// the new switch or null. if tile is the start or end, it doesn't replace it
fn (s: ^Segment) splitAt*(sys: ^System, tile: int): ^Switch {
	if tile > len(s.tiles) { return null }
	if tile == 0 { return &sys.swis[s.swis[0]] }
	if tile == len(s.tiles) - 1 { return &sys.swis[s.swis[1]] }

	// add the switch and init it
	sys.swis = append(sys.swis, Switch{})
	sw := &sys.swis[len(sys.swis) - 1]
	sw.segs = make([]int, 2)
	sw.ends = make([]int, 2)
	sw.pos = s.tiles[tile].pos

	// add the segment
	sys.segs = append(sys.segs, Segment{})
	sg := &sys.segs[len(sys.segs) - 1]

	// set tile arrays
	sg.tiles = slice(s.tiles, tile + 1)
	s.tiles = slice(s.tiles, 0, tile)

	// set inding switches
	sg.swis[0] = len(sys.segs) - 1
	sg.swis[1] = s.swis[1]
	s.swis[1] = sg.swis[0]

	// set switch data
	sw.segs[0] = s.index
	sw.segs[1] = sg.index
	sw.ends[0] = 1
	sw.ends[1] = 0

	return sw
}

// places tiles onto map. automatically creates segments and connects them
// to a switch if the tiles pass through it.
fn (s: ^System)	placeTiles*(tiles: []Tile) {

}
