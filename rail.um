
import (
	"th.um"
	"rect.um"
	"canvas.um"
	"libs/list.um"
	"umka-lang/import/map.um"

	"util.um"
	"global.um"
)

type (
	Tile* = struct {
		parent: ^Segment
		index: int
		// rotation isn't consistent. It can be used to rotate textures, but not to
		// get the rails angle.
		rotation: th.fu
		pos: th.Vf2
	}

	// Switch is multiple segments ending in one place. Even signal is a switch,
	// but with only two segments.
	Switch* = struct {
		segs: []^Segment
		// which end of respective segment is part of the switch
		ends: []int
		pos: th.Vf2
		id: int
	}

	// an edge between two switches
	Segment* = struct {
		// switches on both ends of the segment. shouldn't be null
		swis: [2]^Switch
		// segment's tiles
		tiles: []Tile

		occ: ^Agent
	}

	// A subset of train used in simulation
	Agent* = struct {
		length: int

		// max speed in tiles per ms
		maxSpeed: th.fu
		// current speed in tiles per ms
		speed: th.fu
		// acceleration per ms
		accel: th.fu
		// braking per ms
		braking: th.fu

		// path the agent goes through. nulls are switches
		path: []^Tile

		// index on which the trains tail is
		tail: th.fu

		// agent state
		state: int
	}
)

type System* = struct {
	// map of what switch is on said position
	swisMap: [][]^Switch
	// map of what tile is on said position
	tiles: [][]^Tile
	// list of switches
	swis: []^Switch
	// list of segments
	segs: []^Segment

	// switch id counter
	swid: int
}

const (
	agIdle = 0
	agAccel
	agBrake
)

var (
	path*: []^Segment								
)

// still hardcoded. todo
fn worldToSys*(p: th.Vf2): th.Vf2 {
	return p.div(th.Vf2{2, 2})
}

fn sysToWorld*(p: th.Vf2): th.Vf2 {
	return p.mul(th.Vf2{2, 2})
}

// returns a pointer to position in tile map
fn (sys: ^System) at*(p: th.Vf2): ^^Tile {
	return &sys.tiles[trunc(p.x)][trunc(p.y)]
}

// return a pointer to position in switch map
fn (sys: ^System) atSwis(p: th.Vf2): ^^Switch {
	return &sys.swisMap[trunc(p.x)][trunc(p.y)]
}

// resets the system
fn (s: ^System) reset*() {
	for i, l in s.tiles {
		for j, _ in l {
			s.tiles[i][j] = null
		}
	}

	for i, l in s.swisMap {
		for j, _ in l {
			s.swisMap[i][j] = null
		}
	}

	s.swis = []^Switch{}
	s.segs = []^Segment{}
}

// initializes the system with given size
fn (sys: ^System) initSize(x, y: int) {
	sys.tiles = make([][]^Tile, x)
	for i, c in sys.tiles {
		sys.tiles[i] = make([]^Tile, y)
	}

	sys.swisMap = make([][]^Switch, x)
	for i, c in sys.swisMap {
		sys.swisMap[i] = make([]^Switch, y)
	}
}

// removes a switch
fn (sw: ^Switch) rm(sys: ^System) {
	if len(sw.segs) != 0 {
		return
	}

	sys.atSwis(sw.pos)^ = null
	for i, s in sys.swis {
		if s == sw {
			sys.swis = delete(sys.swis, i)
		}
	}
}

// disconnets segment from a switch. removes switch if needed
fn (sg: ^Segment) disconnect*(sys: ^System, sw: ^Switch) {
	index := -1
	for i, s in sw.segs {
		if s == sg {
			index = i
			break
		}
	}

	if index != -1 {
		sw.segs = delete(sw.segs, index)
		sw.ends = delete(sw.ends, index)
	}

	if len(sw.segs) == 0 {
		sw.rm(sys)
	}
}

// connects segment to a switch
fn (s: ^Segment) connect*(sys: ^System, sw: ^Switch, side: int) {
	if s.swis[side] != null {
		s.disconnect(sys, s.swis[side])
	}
	s.swis[side] = sw

	sw.segs = append(sw.segs, s)
	sw.ends = append(sw.ends, side)
}

// removes a segment
fn (sg: ^Segment) rm(sys: ^System) {
	sg.disconnect(sys, sg.swis[0])
	sg.disconnect(sys, sg.swis[1])

	for i, s in sys.segs {
		if s == sg {
			sys.segs = delete(sys.segs, i)
		}
	}
}

// creates a switch
fn (sys: ^System) mkSwitch(pos: th.Vf2): ^Switch {
	sys.swis = append(sys.swis, new(Switch))
	sw := sys.swis[len(sys.swis) - 1]
	sw.id = sys.swid
	sys.swid++
	sw.segs = []^Segment{}
	sw.ends = []int{}
	sw.pos = pos
	sys.swisMap[round(pos.x)][round(pos.y)] = sw
	return sw
}

// creates a segment
fn (sys: ^System) mkSegment(): ^Segment {
	sys.segs = append(sys.segs, new(Segment))
	sg := sys.segs[len(sys.segs)- 1]
	return sg
}

// rebuilds segments's tiles in the tile map
fn (sg: ^Segment) rebuildTiles(sys: ^System) {
	for i, t in sg.tiles {
		sg.tiles[i].index = i
		sg.tiles[i].parent = sg
		sys.at(sg.tiles[i].pos)^ = &sg.tiles[i]
	}
}

// returns pointer to the switch on opposite side of sg
fn (sg: ^Segment) oppositeSw(sw: ^Switch): ^Switch {
	if sw == sg.swis[0] {
		return sg.swis[1]
	}
	return sg.swis[0]
}

// replaces `tile` by a switch connecting both sides of the segment and returns
// the new switch or null. if tile is the start or end, it doesn't replace it
fn (s: ^Segment) splitAt*(sys: ^System, tile: int): ^Switch {
	if tile > len(s.tiles) { return null }
	if tile == 0 { return s.swis[0] }
	if tile == len(s.tiles) - 1 { return s.swis[1] }

	// add the switch and init it
	sw := sys.mkSwitch(s.tiles[tile].pos)

	// add the segment
	sg := sys.mkSegment()

	// set tile arrays
	sg.tiles = slice(s.tiles, tile + 1)
	s.tiles = slice(s.tiles, 0, tile)

	// fix tile map
	for i, t in s.tiles {
		sys.at(t.pos)^ = &s.tiles[i]
	}

	for i, t in sg.tiles {
		sys.at(t.pos)^ = &sg.tiles[i]
		sg.tiles[i].index -= tile + 1
		sg.tiles[i].parent = sg
	}

	sys.at(sw.pos)^ = null

	sg.connect(sys, sw, 0)
	sg.connect(sys, s.swis[1], 1)
	s.connect(sys, sw, 1)

	return sw
}

// places tiles onto map. automatically creates segments and connects them
// to a switch if the tiles pass through it.
fn (sys: ^System)	placeTiles*(tiles: []Tile) {
	sg := sys.mkSegment()

	sg.tiles = slice(tiles, 1)
	if sw := sys.swisMap[round(tiles[0].pos.x)][round(tiles[0].pos.y)]; sw != null {
		sg.connect(sys, sw, 0)
	} else if isgt := sys.tiles[round(tiles[0].pos.x)][round(tiles[0].pos.y)]; isgt != null {
		sw := isgt.parent.splitAt(sys, sys.tiles[round(tiles[0].pos.x)][round(tiles[0].pos.y)].index)
		sg.connect(sys, sw, 0)
	} else {
		sg.connect(sys, sys.mkSwitch(tiles[0].pos), 0)
	}

	last := 1
	for i:=1; i < len(tiles) - 1; i++ {
		t := tiles[i]
		var toConnect: ^Switch

		// find whether current segment should be closed and a new one created
		if sw := sys.swisMap[round(t.pos.x)][round(t.pos.y)]; sw != null {
			sg.connect(sys, sw, 1)
			toConnect = sw
		} else if isgt := sys.tiles[round(t.pos.x)][round(t.pos.y)]; isgt != null {
			sw := isgt.parent.splitAt(sys, isgt.index)
			sg.connect(sys, sw, 1)
			toConnect = sw
		}

		if toConnect != null {
			sg.tiles = slice(tiles, last, i)	
			// fill sys tile map with tiles
			for i, t in sg.tiles {
				sys.tiles[round(t.pos.x)][round(t.pos.y)] = &sg.tiles[i]
				sg.tiles[i].parent = sg
				sg.tiles[i].index = i
			}

			// create the new segment
			sg = sys.mkSegment()
			sg.connect(sys, toConnect, 0)
			last = i + 1
		}
	}
	
	sg.tiles = slice(tiles, last)
	t := tiles[len(tiles) - 1]
	if sw := sys.swisMap[round(t.pos.x)][round(t.pos.y)]; sw != null {
		sg.connect(sys, sw, 1)
	} else if isgt := sys.tiles[round(t.pos.x)][round(t.pos.y)]; isgt != null {
		sw := isgt.parent.splitAt(sys, sys.tiles[round(t.pos.x)][round(t.pos.y)].index)
		sg.connect(sys, sw, 1)
	} else {
		sg.connect(sys, sys.mkSwitch(t.pos), 1)
	}
	for i, t in sg.tiles {
		sys.tiles[round(t.pos.x)][round(t.pos.y)] = &sg.tiles[i]
		sg.tiles[i].parent = sg
		sg.tiles[i].index = i
	}
}

// reduces rails between start and end inclusive
fn (sg: ^Segment) reduce*(sys: ^System, start, end: int) {
	for i:=start; i < end; i++ {
		x := round(sg.tiles[i].pos.x)
		y := round(sg.tiles[i].pos.y)
		sys.tiles[x][y] = null
	}

	// whole segment
	if start == 0 && end >= len(sg.tiles) - 1 {
		sg.rm(sys)
	// trim end
	} else if start == 0 {
		sg.disconnect(sys, sg.swis[0])
		t := sg.tiles[end + 1]
		sg.tiles = slice(sg.tiles, end + 1)
		sw := sys.mkSwitch(t.pos)
		sg.connect(sys, sw, 0)
	// trim start
	} else if end >= len(sg.tiles) - 1 {
		sg.disconnect(sys, sg.swis[1])
		t := sg.tiles[start - 1]
		sg.tiles = slice(sg.tiles, 0, start - 1)
		sw := sys.mkSwitch(t.pos)
		sg.connect(sys, sw, 1)
	// reduce middle
	} else {
		sg.disconnect(sys, sg.swis[1])

		sg2 := sys.mkSegment()
		sg2.connect(sys, sg.swis[1], 1)
		sg2.tiles = slice(sg.tiles, end + 1)
		sg2.connect(sys, sys.mkSwitch(sg.tiles[end + 1].pos), 0)

		sg.connect(sys, sys.mkSwitch(sg.tiles[start - 1].pos), 1)
		sg.tiles = slice(sg.tiles, 0, start - 1)
	}
}

// checks whether a list of tiles can be placed into the system
fn (sys: ^System) canPlace*(tiles: []Tile): bool {
	if len(tiles) <= 2 {
		return false
	}

	var sg: ^Segment
	v := tiles[1].pos.sub(tiles[0].pos)
	left := v.rotated(th.Vf2{}, -90)
	right := v.rotated(th.Vf2{}, 90)
	for i, t in tiles {
		// if there is an adjacent rail somewhere else than the start and en
		lt := sys.at(t.pos.add(left))^
		rt := sys.at(t.pos.add(right))^
		if (lt != null && round(fabs(lt.rotation - t.rotation)) % 180 == 0) ||
			(rt != null && round(fabs(rt.rotation - t.rotation)) % 180 == 0) {
			return false
		}

		t2 := sys.at(t.pos)^
		if t2 == null {
			continue
		}

		if sg == t2.parent {
			return false
		}
		sg = t2.parent
	}

	return true
}

// returns angle between a segment and a switch
fn (sg: ^Segment) angle(sw: ^Switch): int {
	last := sg.tiles[1]
	if sw != sg.swis[0] {
		last = sg.tiles[len(sg.tiles) - 2]
	}
	return round(util.snap(last.pos.angleTo(sw.pos), 45))
}

// checks whether two segmeent are adjacent
fn (sw: ^Switch) areAdjacent(sg1, sg2: ^Segment): bool {
	a1 := sg1.angle(sw)
	a2 := sg2.angle(sw) - 180
	for a2 < 0 { a2 += 360 }

	diff := fabs(fabs(a1) - fabs(a2))
	return diff <= 45 || diff >= 315 || diff == 180
}

// checks whether a switch can be merged
fn (sw: ^Switch) canMerge*(): bool {
	if len(sw.segs) != 2 {
		return false
	}

	if sw.segs[0] == sw.segs[1] {
		return false
	}

	return sw.areAdjacent(sw.segs[0], sw.segs[1])
}

// reverses an array of tiles
fn revTiles(tiles: []Tile): []Tile {
	for i:=0; i < len(tiles) / 2; i++ {
		tmp := tiles[i]
		i2 := len(tiles) - 1 - i
		tiles[i] = tiles[i2]
		tiles[i2] = tmp
	}

	return tiles
}

// merges a switch if possible
fn (sw: ^Switch) merge*(sys: ^System): ^Segment {
	if !sw.canMerge() {
		return null
	}

	sg1 := sw.segs[0]
	sg2 := sw.segs[1]

	swt := Tile{sg1, len(sg1.tiles), sg2.tiles[0].rotation, sw.pos}

	if sw.ends[0] == 0 {
		if sw.ends[1] == 0 {
			sg2.tiles = revTiles(sg2.tiles)
		}
		tiles := append(sg2.tiles, swt)
		tiles = append(tiles, sg1.tiles)
		sg1.tiles = tiles
	} else {
		tiles := append(sg1.tiles, swt)
		if sw.ends[1] == 1 {
			sg2.tiles = revTiles(sg2.tiles)
		}
		sg1.tiles = append(tiles, sg2.tiles)
	}

	sg1.connect(sys, sg2.swis[~sw.ends[1] & 1], sw.ends[0])

	sg1.rebuildTiles(sys)

	sg2.rm(sys)

	return sg1
}

// heuristic function for distance used in navigation
fn (sys: ^System) navDist*(from, to: ^Switch): th.fu {
	return from.pos.distanceTo(to.pos)
}

// navigates between two switches
fn (sys: ^System) navigate*(from, to: ^Switch): []^Segment {
	q := list.List{}
	q.push_front(from)

	cameFrom := map.Map{}
	cost := map.Map{}
	cost.set(from.id, 0)
	hcost := map.Map{}
	hcost.set(from.id, sys.navDist(from, to))

	for q.length != 0 {
		c := ^Switch(q.front.value)
		q.remove(q.front)
		if c == to {
			out := []^Segment{}
			for c != from {
				sg := ^Segment(cameFrom.get(c.id))
				out = append([]^Segment{ sg }, out)
				c = sg.oppositeSw(c)
			}
			return out
		}

		for i,sg in c.segs {
			score := int(cost.get(c.id)) + len(sg.tiles)
			sw := sg.oppositeSw(c)

			cf := ^Segment(cameFrom.get(c.id))
			if cf != null && !c.areAdjacent(cf, sg) {
				continue
			}
			
			if ^int(cost.get(sw.id)) != null && int(cost.get(sw.id)) < score {
				continue
			}

			cameFrom.set(sw.id, sg)
			cost.set(sw.id, score)
			hscore := score + sys.navDist(sw, to)
			hcost.set(sw.id, hscore)
			set := false
			for n:=q.front; n != null; n=n.next {
				s := ^Switch(n.value)
				if ^Switch(n.value) == sw {
						break
				}

				if (!set && real(hcost.get( s.id )) < hscore) || n.next == null {
					q.insert_after(n, sw)
					n = n.next
				}
			}

			if q.front == null {
				q.push_front(sw)
			}
		}
	}

	return []^Segment{}
}

fn (ag: ^Agent) markSegs() {
	b := round((ag.speed * ag.speed) / (2 * ag.braking) + ag.length)

	if ag.state == agBrake {
		ag.state = agIdle
	} else {
		ag.state = agAccel
	}

	for a:=0; b > 0; b-=1 {
		if round(b + ag.tail) >= len(ag.path) {
			ag.state = agBrake
			break
		}

		if ag.path[round(b + ag.tail)] == null {
			continue
		}
		p := ag.path[round(b + ag.tail)].parent
		if p.occ != null && p.occ != ag {
			ag.state = agBrake
			break
		}

		p.occ = ag
	}
}

fn (ag: ^Agent) move(delta: th.fu) {
	ot := ag.tail
	ag.tail += ag.speed * delta

	// remove tail segs
	for a:=0; round(ot) < round(ag.tail); ot+=1 {
		if ag.path[round(ot)] == null {
			continue
		}
		ag.path[round(ot)].parent.occ = null
	}

	ag.markSegs()
}

// only debug
fn (ag: ^Agent) draw*() {
	if len(ag.path) == 0 {
		return
	}

	const cellSize = 2
	canvas.setColor(th.black)
	c := global.cam
	c.x /= cellSize
	c.y /= cellSize
	c.w /= cellSize
	c.h /= cellSize

	canvas.drawText(
		"Agent:" +
		"\n  tail: " + repr(ag.tail) +
		"\n  speed: " + repr(ag.speed) +
		"\n  mode: " + repr(ag.state),
		th.Vf2{0, 20}, th.black, 1)

	canvas.setColor(th.green)
	for i:=ag.tail; i < ag.tail + ag.length; i+=1 {
		t := ag.path[round(i)]
		if t == null {
			continue
		}

		p := c.toScreen(t.pos)
		canvas.drawRect(rect.mk(
			p.x * cellSize, p.y * cellSize, cellSize, cellSize))
	}
}

fn (ag: ^Agent) setPath*(sys: ^System, from, to: ^Switch) {
	p := sys.navigate(from, to)
	ag.path = []^Tile{}
	for i,sg in p {
		off := len(ag.path)
		// +1 for the switch
		ag.path = append(ag.path, make([]^Tile, len(sg.tiles) + 1))

		rev := false
		if i == 0 {
			sg2 := p[i + 1]
			if sg.swis[0] == sg2.swis[0] || sg.swis[0] == sg2.swis[1] {
				rev = true
			}
		} else {
			sg2 := p[i - 1]
			if sg.swis[1] == sg2.swis[0] || sg.swis[1] == sg2.swis[1] {
				rev = true
			}
		}

		printf("%s\n", repr(rev))
		for i,t in sg.tiles {
			index := i
			if rev {
				index = len(sg.tiles) - 1 - i
			}
			ag.path[off + i] = &sg.tiles[index]
		}
	}

	ag.tail = 0
}

fn (ag: ^Agent) update*(delta: th.fu) {
	if len(ag.path) == 0 {
		return
	}

	switch ag.state {
	case agIdle:
	case agAccel:
		ag.speed += ag.accel * delta
		if ag.speed > ag.maxSpeed {
			ag.speed = ag.maxSpeed
		}
	case agBrake:
		ag.speed -= ag.braking * delta
	}

	ag.move(delta)
}

// draws the system
fn (sys: ^System) draw*(cam: rect.Rect) {
	const cellSize = 2
	
	canvas.setColor(th.black)
	c := global.cam
	c.x /= cellSize
	c.y /= cellSize
	c.w /= cellSize
	c.h /= cellSize


	for sg in sys.segs {
		for t in sg.tiles {
			p := c.toScreen(t.pos)
			canvas.drawRect(rect.mk(
				p.x * cellSize, p.y * cellSize, cellSize, cellSize))
		}
	}

	canvas.setColor(th.yellow)
	for sg in path {
		for t in sg.tiles {
			p := c.toScreen(t.pos)
			canvas.drawRect(rect.mk(
				p.x * cellSize, p.y * cellSize, cellSize, cellSize))
		}
	}

	canvas.setColor(th.red)
	for sw in sys.swis {
		p := c.toScreen(sw.pos)
		canvas.setColor(th.red)
		canvas.drawRect(rect.mk(
			p.x * cellSize, p.y * cellSize, cellSize, cellSize))
		canvas.drawText(repr(sw.id), th.Vf2{p.x * cellSize, p.y * cellSize}, th.cyan, 0.8)
	}
}
