
import (
	"th.um"
	"rect.um"
	"canvas.um"
	"libs/list.um"
	"umka-lang/import/map.um"

	"util.um"
	"global.um"
)

type (
	Tile* = struct {
		parent: ^Segment
		index: int
		rotation: th.fu
		pos: th.Vf2
	}

	// Switch is multiple segments ending in one place. Even signal is a switch,
	// but with only two segments.
	Switch* = struct {
		segs: []^Segment
		// which end of respective segment is part of the switch
		ends: []int
		pos: th.Vf2
		id: int
	}

	Segment* = struct {
		swis: [2]^Switch
		tiles: []Tile
	}
)

type System* = struct {
	swisMap: [][]^Switch
	tiles: [][]^Tile
	swis: []^Switch
	segs: []^Segment
	swid: int
}

var (
	path*: []^Segment								
)

// still hardcoded. todo
fn worldToSys*(p: th.Vf2): th.Vf2 {
	return p.div(th.Vf2{2, 2})
}

fn sysToWorld*(p: th.Vf2): th.Vf2 {
	return p.mul(th.Vf2{2, 2})
}

fn (sys: ^System) at*(p: th.Vf2): ^^Tile {
	return &sys.tiles[trunc(p.x)][trunc(p.y)]
}

fn (sys: ^System) atSwis(p: th.Vf2): ^^Switch {
	return &sys.swisMap[trunc(p.x)][trunc(p.y)]
}

fn (s: ^System) reset*() {
	for i, l in s.tiles {
		for j, _ in l {
			s.tiles[i][j] = null
		}
	}

	for i, l in s.swisMap {
		for j, _ in l {
			s.swisMap[i][j] = null
		}
	}

	s.swis = []^Switch{}
	s.segs = []^Segment{}
}

fn (sys: ^System) initSize(x, y: int) {
	sys.tiles = make([][]^Tile, x)
	for i, c in sys.tiles {
		sys.tiles[i] = make([]^Tile, y)
	}

	sys.swisMap = make([][]^Switch, x)
	for i, c in sys.swisMap {
		sys.swisMap[i] = make([]^Switch, y)
	}
}

fn (sw: ^Switch) rm(sys: ^System) {
	if len(sw.segs) != 0 {
		return
	}

	sys.atSwis(sw.pos)^ = null
	for i, s in sys.swis {
		if s == sw {
			sys.swis = delete(sys.swis, i)
		}
	}
}

fn (sg: ^Segment) disconnect*(sys: ^System, sw: ^Switch) {
	index := -1
	for i, s in sw.segs {
		if s == sg {
			index = i
			break
		}
	}

	if index != -1 {
		sw.segs = delete(sw.segs, index)
		sw.ends = delete(sw.ends, index)
	}

	if len(sw.segs) == 0 {
		sw.rm(sys)
	}
}

fn (s: ^Segment) connect*(sys: ^System, sw: ^Switch, side: int) {
	if s.swis[side] != null {
		s.disconnect(sys, s.swis[side])
	}
	s.swis[side] = sw

	sw.segs = append(sw.segs, s)
	sw.ends = append(sw.ends, side)
}

fn (sg: ^Segment) rm(sys: ^System) {
	sg.disconnect(sys, sg.swis[0])
	sg.disconnect(sys, sg.swis[1])

	for i, s in sys.segs {
		if s == sg {
			sys.segs = delete(sys.segs, i)
		}
	}
}

fn (sys: ^System) mkSwitch(pos: th.Vf2): ^Switch {
	sys.swis = append(sys.swis, new(Switch))
	sw := sys.swis[len(sys.swis) - 1]
	sw.id = sys.swid
	sys.swid++
	sw.segs = []^Segment{}
	sw.ends = []int{}
	sw.pos = pos
	sys.swisMap[round(pos.x)][round(pos.y)] = sw
	return sw
}

fn (sys: ^System) mkSegment(): ^Segment {
	sys.segs = append(sys.segs, new(Segment))
	sg := sys.segs[len(sys.segs)- 1]
	return sg
}

fn (sg: ^Segment) rebuildTiles(sys: ^System) {
	for i, t in sg.tiles {
		sg.tiles[i].index = i
		sg.tiles[i].parent = sg
		sys.at(sg.tiles[i].pos)^ = &sg.tiles[i]
	}
}

fn (sg: ^Segment) oppositeSw(sw: ^Switch): ^Switch {
	if sw == sg.swis[0] {
		return sg.swis[1]
	}
	return sg.swis[0]
}

// replaces `tile` by a switch connecting both sides of the segment and returns
// the new switch or null. if tile is the start or end, it doesn't replace it
fn (s: ^Segment) splitAt*(sys: ^System, tile: int): ^Switch {
	if tile > len(s.tiles) { return null }
	if tile == 0 { return s.swis[0] }
	if tile == len(s.tiles) - 1 { return s.swis[1] }

	// add the switch and init it
	sw := sys.mkSwitch(s.tiles[tile].pos)

	// add the segment
	sg := sys.mkSegment()

	// set tile arrays
	sg.tiles = slice(s.tiles, tile + 1)
	s.tiles = slice(s.tiles, 0, tile)

	// fix tile map
	for i, t in s.tiles {
		sys.at(t.pos)^ = &s.tiles[i]
	}

	for i, t in sg.tiles {
		sys.at(t.pos)^ = &sg.tiles[i]
		sg.tiles[i].index -= tile + 1
		sg.tiles[i].parent = sg
	}

	sys.at(sw.pos)^ = null

	sg.connect(sys, sw, 0)
	sg.connect(sys, s.swis[1], 1)
	s.connect(sys, sw, 1)

	return sw
}

// places tiles onto map. automatically creates segments and connects them
// to a switch if the tiles pass through it.
fn (sys: ^System)	placeTiles*(tiles: []Tile) {
	sg := sys.mkSegment()

	sg.tiles = slice(tiles, 1)
	if sw := sys.swisMap[round(tiles[0].pos.x)][round(tiles[0].pos.y)]; sw != null {
		sg.connect(sys, sw, 0)
	} else if isgt := sys.tiles[round(tiles[0].pos.x)][round(tiles[0].pos.y)]; isgt != null {
		sw := isgt.parent.splitAt(sys, sys.tiles[round(tiles[0].pos.x)][round(tiles[0].pos.y)].index)
		sg.connect(sys, sw, 0)
	} else {
		sg.connect(sys, sys.mkSwitch(tiles[0].pos), 0)
	}

	last := 1
	for i:=1; i < len(tiles) - 1; i++ {
		t := tiles[i]
		var toConnect: ^Switch

		// find whether current segment should be closed and a new one created
		if sw := sys.swisMap[round(t.pos.x)][round(t.pos.y)]; sw != null {
			sg.connect(sys, sw, 1)
			toConnect = sw
		} else if isgt := sys.tiles[round(t.pos.x)][round(t.pos.y)]; isgt != null {
			sw := isgt.parent.splitAt(sys, isgt.index)
			sg.connect(sys, sw, 1)
			toConnect = sw
		}

		if toConnect != null {
			sg.tiles = slice(tiles, last, i)	
			// fill sys tile map with tiles
			for i, t in sg.tiles {
				sys.tiles[round(t.pos.x)][round(t.pos.y)] = &sg.tiles[i]
				sg.tiles[i].parent = sg
				sg.tiles[i].index = i
			}

			// create the new segment
			sg = sys.mkSegment()
			sg.connect(sys, toConnect, 0)
			last = i + 1
		}
	}
	
	sg.tiles = slice(tiles, last)
	t := tiles[len(tiles) - 1]
	if sw := sys.swisMap[round(t.pos.x)][round(t.pos.y)]; sw != null {
		sg.connect(sys, sw, 1)
	} else if isgt := sys.tiles[round(t.pos.x)][round(t.pos.y)]; isgt != null {
		sw := isgt.parent.splitAt(sys, sys.tiles[round(t.pos.x)][round(t.pos.y)].index)
		sg.connect(sys, sw, 1)
	} else {
		sg.connect(sys, sys.mkSwitch(t.pos), 1)
	}
	for i, t in sg.tiles {
		sys.tiles[round(t.pos.x)][round(t.pos.y)] = &sg.tiles[i]
		sg.tiles[i].parent = sg
		sg.tiles[i].index = i
	}
}

// reduces rails between start and end inclusive
fn (sg: ^Segment) reduce*(sys: ^System, start, end: int) {
	for i:=start; i < end; i++ {
		x := round(sg.tiles[i].pos.x)
		y := round(sg.tiles[i].pos.y)
		sys.tiles[x][y] = null
	}

	// whole segment
	if start == 0 && end >= len(sg.tiles) - 1 {
		sg.rm(sys)
	// trim end
	} else if start == 0 {
		sg.disconnect(sys, sg.swis[0])
		t := sg.tiles[end + 1]
		sg.tiles = slice(sg.tiles, end + 1)
		sw := sys.mkSwitch(t.pos)
		sg.connect(sys, sw, 0)
	// trim start
	} else if end >= len(sg.tiles) - 1 {
		sg.disconnect(sys, sg.swis[1])
		t := sg.tiles[start - 1]
		sg.tiles = slice(sg.tiles, 0, start - 1)
		sw := sys.mkSwitch(t.pos)
		sg.connect(sys, sw, 1)
	// reduce middle
	} else {
		sg.disconnect(sys, sg.swis[1])

		sg2 := sys.mkSegment()
		sg2.connect(sys, sg.swis[1], 1)
		sg2.tiles = slice(sg.tiles, end + 1)
		sg2.connect(sys, sys.mkSwitch(sg.tiles[end + 1].pos), 0)

		sg.connect(sys, sys.mkSwitch(sg.tiles[start - 1].pos), 1)
		sg.tiles = slice(sg.tiles, 0, start - 1)
	}
}

fn (sys: ^System) canPlace*(tiles: []Tile): bool {
	if len(tiles) <= 2 {
		return false
	}

	var sg: ^Segment
	v := tiles[1].pos.sub(tiles[0].pos)
	left := v.rotated(th.Vf2{}, -90)
	right := v.rotated(th.Vf2{}, 90)
	for i, t in tiles {
		// if there is an adjacent rail somewhere else than the start and en
		lt := sys.at(t.pos.add(left))^
		rt := sys.at(t.pos.add(right))^
		if (lt != null && round(fabs(lt.rotation - t.rotation)) % 180 == 0) ||
			(rt != null && round(fabs(rt.rotation - t.rotation)) % 180 == 0) {
			return false
		}

		t2 := sys.at(t.pos)^
		if t2 == null {
			continue
		}

		if sg == t2.parent {
			return false
		}
		sg = t2.parent
	}

	return true
}

fn (sw: ^Segment) angle(end: int): int {
	last := sw.tiles[ (len(sw.tiles) - 2) * end ]
	return round(util.snap(last.pos.angleTo(sw.swis[end].pos), 45))
}

fn (sw: ^Switch) areAdjacent(si1, si2: int): bool {
	sg1 := sw.segs[si1]
	sg2 := sw.segs[si2]

	a1 := sg1.angle(sw.ends[si1])
	a2 := sg2.angle(sw.ends[si2]) - 180
	for a2 < 0 { a2 += 360 }

	diff := fabs(fabs(a1) - fabs(a2))
	return diff <= 45 || diff >= 315
}

fn (sw: ^Switch) canMerge*(): bool {
	if len(sw.segs) != 2 {
		return false
	}

	if sw.segs[0] == sw.segs[1] {
		return false
	}

	return sw.areAdjacent(0, 1)
}

fn revTiles(tiles: []Tile): []Tile {
	for i:=0; i < len(tiles) / 2; i++ {
		tmp := tiles[i]
		i2 := len(tiles) - 1 - i
		tiles[i] = tiles[i2]
		tiles[i2] = tmp
	}

	return tiles
}

fn (sw: ^Switch) merge*(sys: ^System): ^Segment {
	if !sw.canMerge() {
		return null
	}

	sg1 := sw.segs[0]
	sg2 := sw.segs[1]

	swt := Tile{sg1, len(sg1.tiles), sg2.tiles[0].rotation, sw.pos}

	if sw.ends[0] == 0 {
		if sw.ends[1] == 0 {
			sg2.tiles = revTiles(sg2.tiles)
		}
		tiles := append(sg2.tiles, swt)
		tiles = append(tiles, sg1.tiles)
		sg1.tiles = tiles
	} else {
		tiles := append(sg1.tiles, swt)
		if sw.ends[1] == 1 {
			sg2.tiles = revTiles(sg2.tiles)
		}
		sg1.tiles = append(tiles, sg2.tiles)
	}

	sg1.connect(sys, sg2.swis[~sw.ends[1] & 1], sw.ends[0])

	sg1.rebuildTiles(sys)

	sg2.rm(sys)

	return sg1
}

fn (sys: ^System) navDist*(from, to: ^Switch): th.fu {
	return from.pos.distanceTo(to.pos)
}

fn (sys: ^System) navigate*(from, to: ^Switch): []^Segment {
	q := list.List{}
	q.push_front(from)

	cameFrom := map.Map{}
	cost := map.Map{}
	cost.set(from.id, 0)
	hcost := map.Map{}
	hcost.set(from.id, sys.navDist(from, to))

	for q.length != 0 {
		c := ^Switch(q.front.value)
		q.remove(q.front)
		printf("%d\n", c.id)
		if c == to {
			out := []^Segment{}
			for c != from {
				sg := ^Segment(cameFrom.get(c.id))
				out = append([]^Segment{ sg }, out)
				c = sg.oppositeSw(c)
			}
			return out
		}

		for i,sg in c.segs {
			score := int(cost.get(c.id)) + len(sg.tiles)
			sw := sg.oppositeSw(c)
			if ^int(cost.get(sw.id)) != null && int(cost.get(sw.id)) < score {
				continue
			}

			cameFrom.set(sw.id, sg)
			cost.set(sw.id, score)
			hscore := score + sys.navDist(sw, to)
			hcost.set(sw.id, hscore)
			set := false
			for n:=q.front; n != null; n=n.next {
				s := ^Switch(n.value)
				if ^Switch(n.value) == sw {
						break
				}

				if (!set && real(hcost.get( s.id )) < hscore) || n.next == null {
					q.insert_after(n, sw)
					n = n.next
				}
			}

			if q.front == null {
				q.push_front(sw)
			}
		}
	}

	return []^Segment{}
}

fn (sys: ^System) draw(cam: rect.Rect) {
	const cellSize = 2
	
	canvas.setColor(th.black)
	c := global.cam
	c.x /= cellSize
	c.y /= cellSize
	c.w /= cellSize
	c.h /= cellSize

	for sg in sys.segs {
		for t in sg.tiles {
			p := c.toScreen(t.pos)
			canvas.drawRect(rect.mk(
				p.x * cellSize, p.y * cellSize, cellSize, cellSize))
		}
	}

	canvas.setColor(th.yellow)
	for sg in path {
		for t in sg.tiles {
			p := c.toScreen(t.pos)
			canvas.drawRect(rect.mk(
				p.x * cellSize, p.y * cellSize, cellSize, cellSize))
		}
	}

	canvas.setColor(th.red)
	for sw in sys.swis {
		p := c.toScreen(sw.pos)
		canvas.setColor(th.red)
		canvas.drawRect(rect.mk(
			p.x * cellSize, p.y * cellSize, cellSize, cellSize))
		canvas.drawText(repr(sw.id), th.Vf2{p.x * cellSize, p.y * cellSize}, th.cyan, 0.8)
	}
}
