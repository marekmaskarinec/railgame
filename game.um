
import (
	"th.um"
	"ui.um"
	"input.um"

	"util.um"
	"rail.um"
	"level.um"
	"scene.um"
	"editor.um"
	"global.um"
)

const (
	mEditing* = 0
	mRunning*

	panSpeed = 0.05
)

var (
	lvl*: level.Level
	mode: int

	edUi: ui.Grid
	lvlUi: ui.Grid

	camPos: th.Vf2
)

fn reset*(from: int) {
	camPos = th.Vf2{global.cam.x, global.cam.y}
	editor.reset()
	lvl.reset()
}

fn launchTest() {
	lvl.reset()
	lvl.startSim()
	mode = mRunning
}

fn snap*(v, s: th.fu): th.fu {
	return round(v / s) * s
}

fn setUi*() {
	edUi = ui.mkGrid(3, 1)
	edUi.elements = []ui.Element{
		ui.mkLabel(ui.PixelFont{}, "RUN", th.black, 1),
		ui.mkLabel(ui.PixelFont{}, "TEST", th.black, 1),
		ui.mkLabel(ui.PixelFont{}, "", th.black, 1)}
	edUi.border = 2
	edUi.g.t = th.Transform{
		s: th.Vf2{90, 15},
		p: th.Vf2{0, global.cam.h-15}}
	
	btn := ^ui.Label(edUi.elements[0])
	btn.center = true
	btn.bgColor = rail.railColor
	btn.g.ctx = btn
	btn.g.onEvent = fn(eventType: th.uu, ctx: interface{}) {
		if eventType != ui.eventRelease {
			return
		}

		launchTest()
	}

	btn = ^ui.Label(edUi.elements[1])
	btn.center = true
	btn.bgColor = rail.railColor
	btn.g.ctx = btn
	btn.g.onEvent = fn(eventType: th.uu, ctx: interface{}) {
		if eventType != ui.eventRelease {
			return
		}

		lvl.reset()
		ui.Label(edUi.elements[2]).text = "passed in: " + repr(lvl.test())
	}
	btn.g.grid(1, 0)

	edUi.elements[2].get().grid(2, 0)

	lvlUi = ui.mkGrid(2, 1)
	lvlUi.elements = []ui.Element{
		ui.mkLabel(ui.PixelFont{}, "BACK", th.black, 1),
		ui.mkLabel(ui.PixelFont{}, "SKIP", th.black, 1)}
	lvlUi.border = 2
	lvlUi.g.t = th.Transform{
		s: th.Vf2{60, 15},
		p: th.Vf2{0, global.cam.h - 15}}
	
	btn = ^ui.Label(lvlUi.elements[0])
	btn.center = true
	btn.bgColor = rail.railColor
	btn.g.ctx = btn
	btn.g.onEvent = fn(eventType: th.uu, ctx: interface{}) {
		if eventType != ui.eventRelease {
			return
		}

		mode = mEditing
	}

	btn = ^ui.Label(lvlUi.elements[1])
	btn.center = true
	btn.bgColor = rail.railColor
	btn.g.ctx = btn
	btn.g.onEvent = fn(eventType: th.uu, ctx: interface{}) {
		if eventType != ui.eventRelease {
			return
		}

		lvl.skipSim()
	}
	btn.g.grid(1, 0)
}

fn handle*() {
	if input.isPressed(input.key_left) {
		camPos.x -= panSpeed * th.delta
	}
	if input.isPressed(input.key_right) {
		camPos.x += panSpeed * th.delta
	}
	global.cam.x = util.snap(camPos.x, rail.tileSize)
	if input.isPressed(input.key_up) {
		camPos.y -= panSpeed * th.delta
	}
	if input.isPressed(input.key_down) {
		camPos.y += panSpeed * th.delta
	}
	global.cam.y = util.snap(camPos.y, rail.tileSize)

	switch mode {
	case mEditing:
		editor.handle(global.cam)
		edUi.handle()
	case mRunning:
		lvl.handle()
		lvlUi.handle()
	}
}

fn draw*() {
	lvl.sys.draw(global.cam)
	
	switch mode {
	case mEditing:
		editor.draw()
		edUi.draw()
	case mRunning:
		lvl.draw()
		lvlUi.draw()
	}
}

fn init*() {
	lvl.init()
	editor.init(&lvl)

	setUi()

	global.gameId = scene.Scene{
		name: "Game",
		reset: reset,
		handle: handle,
		draw: draw}.register()
}
