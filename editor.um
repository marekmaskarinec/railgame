
import (
	"th.um"
	"std.um"
	"rect.um"
	"misc.um"
	"input.um"
	"canvas.um"

	"rail.um"
	"util.um"
	"global.um"
)

const (
	edOff = 0
	edPlace
	edMerge
	edDel
	edDebug

	modeNames = [5]str{"OFF", "PLACE", "MERGE", "DELETE", "DEBUG"}
)

var (
	mode: int
	sys*: rail.System

	// place mode vars
	origin: th.Vf2
	hasOrigin: bool
	angle: th.fu

	np: th.Vf2
	np2: th.Vf2

	ag: rail.Agent
	ag2: rail.Agent
)

fn reset*() {
	mode = edPlace

	hasOrigin = false
}

fn init*(s: rail.System) {
	reset()
	sys = s

	ag = rail.Agent{
		length: 5,
		maxSpeed: 5.0/1000,
		accel: 0.005/1000,
		braking: 0.002/1000}

	ag2 = rail.Agent{
		length: 3,
		maxSpeed: 3.0/1000,
		accel: 0.5/1000,
		braking: 0.2/1000}
}

fn scanSwitches(p1, p2: th.Vf2): []^rail.Switch {
	n := p2.sub(p1).norm()
	pa := p1.angleTo(p2)
	if pa == 360 { pa = 0 }

	out := []^rail.Switch{}

	for a:=-90.0; a <= 90; a+=45 {
		p := p2
		m := n.rotated(th.Vf2{}, a)

		for i:=0; i < 10; i++ {
			p = p.add(m)
			canvas.drawLine(th.red, p2, p, 1)
			if sys.atSwis(p)^ != null {
				out = append(out, sys.atSwis(p)^)				
				break
			}
		}
	}

	return out
}

fn genPlaceTiles(p2: th.Vf2): []rail.Tile {
	p := origin
	if p.x < p2.x || p.y < p2.y {
		tmp := p
		p = p2
		p2 = tmp
	}

	n := p2.sub(p).norm()
	tiles := make([]rail.Tile, round(p.distanceTo(p2) / n.mag()) + 1)

	a := round(p.angleTo(p2)) % 360

	for i, t in tiles {
		tiles[i].pos = p
		tiles[i].rotation = a
		p = p.add(n)
	}

	return tiles
}

fn place*(p2: th.Vf2) {
	tiles := genPlaceTiles(p2)
	sys.placeTiles(tiles)
}

fn snap*(v, s: th.fu): th.fu {
 return round(v / s) * s
}

fn handle*(cam: rect.Rect) {
	if input.isJustPressed('p') {
		mode = edPlace
	} else if input.isJustPressed('m') {
		mode = edMerge
	} else if input.isJustPressed('d') {
		mode = edDel
	} else if input.isJustPressed('g') {
		mode = edDebug
	}

	if input.isJustPressed('s') {
		f := std.fopen("export.txt", "w")
		fprintf(f, "%s\n", sys.export())
		std.fclose(f)
	} else if input.isJustPressed('l') {
		sys = rail.load(util.readall("export.txt"))
	}

	switch mode {
	case edPlace:
		for x:=0.0; x < global.cam.w; x+=rail.tileSize {
			if round(x / rail.tileSize) % 2 == 0 {
				continue
			}
			canvas.drawRect(0x22, rect.mk(x, 0, rail.tileSize, global.cam.h))
		}
  
		for y:=0.0; y < global.cam.h; y+=rail.tileSize {
			if round(y / rail.tileSize) % 2 == 0 {
				continue
			}
			canvas.drawRect(0x22, rect.mk(0, y, global.cam.w, rail.tileSize))
		}

		mp := rail.worldToSys(input.getGlobalMousePos(global.cam)).flr()

		if hasOrigin {
			p2 := th.Vf2{ 0, -origin.distanceTo(mp) }.
				rotated(th.Vf2{0, 0}, angle + 90).
				add(origin).
				rnd()
			canPlace := false

			if origin.x != p2.x || origin.y != p2.y {
				angle = snap(mp.angleTo(origin), 45)
				canPlace = sys.canPlace(genPlaceTiles(p2))

				if !input.isPressed(input.mouse1) {
					if canPlace { place(p2) }
					hasOrigin = false
				}
			}

			if input.isJustPressed(input.mouse3) {
				hasOrigin = false
			}

			swis := scanSwitches(origin, p2)
			for sw in swis {
				canvas.drawLine(0x00ff0099,
					rail.sysToWorld(p2).add(th.Vf2{1, 1}),
					rail.sysToWorld(sw.pos).add(th.Vf2{1, 1}), 1)
			}

			color := th.cyan
			if !canPlace { color = th.red }

			canvas.drawLine(color,
				global.cam.toScreen(rail.sysToWorld(origin).add(th.Vf2{1, 1})),
				global.cam.toScreen(rail.sysToWorld(p2).add(th.Vf2{1, 1})),
				rail.tileSize)
		} else {
			if input.isJustPressed(input.mouse1) {
				hasOrigin = true
				origin = mp
			}
		}
	case edMerge:
		mp := rail.worldToSys(input.getGlobalMousePos(global.cam)).flr()
		if input.isJustPressed(input.mouse1) {
			sw := sys.atSwis(mp)^
			if sw != null {
				sw.merge(&sys)
			}
		}
	case edDel:
		mp := rail.worldToSys(input.getGlobalMousePos(global.cam)).flr()
		if input.isJustPressed(input.mouse1) {
			tl := sys.at(mp)^
			if tl != null {
				tl.parent.reduce(&sys, 0, len(tl.parent.tiles))
			}
		}
	case edDebug:
		mp := rail.worldToSys(input.getGlobalMousePos(global.cam)).flr()

		if input.isJustPressed(input.mouse1) && sys.atSwis(mp)^ != null {
			if  np.x == 0 && np.y == 0 {
				np = mp
			} else {
				sw1 := sys.atSwis(np)^
				sw2 := sys.atSwis(mp)^
				rail.path = sys.navigate(sw1, sw2)
				ag.setPath(&sys, sw1, sw2)
				np = th.Vf2{}
			}
		}
		if input.isJustPressed(input.mouse3) && sys.atSwis(mp)^ != null {
			if np2.x == 0 && np2.y == 0 {
				np2 = mp
			} else {
				sw1 := sys.atSwis(np2)^
				sw2 := sys.atSwis(mp)^
				rail.path = sys.navigate(sw1, sw2)
				ag2.setPath(&sys, sw1, sw2)
				np2 = th.Vf2{}
			}
		}
	}

	ag.update(th.delta)
	ag2.update(th.delta)
	ag.draw()
	ag2.draw()

	canvas.drawText(modeNames[mode], th.Vf2{2, 2}, th.black, 2)
}
