
import (
	"th.um"
	"rect.um"
	"misc.um"
	"input.um"
	"canvas.um"

	"rail.um"
)

const (
	edOff = 0
	edPlace
)

var (
	mode: int
	sys*: rail.System

	// place mode vars
	origin: th.Vf2
	hasOrigin: bool
	angle: th.fu
)

fn reset*() {
	mode = edPlace

	hasOrigin = false
}

fn init*(s: rail.System) {
	reset()
	sys = s
}

fn genPlaceTiles(p2: th.Vf2): []rail.Tile {
	n := p2.sub(origin).norm()
	tiles := make([]rail.Tile, round(origin.distanceTo(p2) / n.mag()) + 1)
	p := origin
	for i, t in tiles {
		tiles[i].pos = p
		tiles[i].rotation = angle
		p = p.add(n)
	}

	return tiles
}

fn place*(p2: th.Vf2) {
	tiles := genPlaceTiles(p2)
	sys.placeTiles(tiles)
}

fn snap*(v, s: th.fu): th.fu {
 return round(v / s) * s
}

fn handle*(cam: rect.Rect) {
	switch mode {
	case edPlace:
		mp := rail.worldToSys(input.getMousePos()).flr()

		if hasOrigin {
			p2 := th.Vf2{ 0, -origin.distanceTo(mp) }.rotated(th.Vf2{0, 0}, angle + 90).add(origin).rnd()
			canPlace := false

			if origin.x != p2.x || origin.y != p2.y {
				angle = snap(mp.angleTo(origin), 45)
				printf("%f\n", angle)
				canPlace = sys.canPlace(genPlaceTiles(p2))

				if !input.isPressed(input.mouse1) {
					if canPlace { place(p2) }
					hasOrigin = false
				}
			}

			if input.isJustPressed(input.mouse3) {
				hasOrigin = false
			}

      camOff := th.Vf2{cam.w / 2, cam.h / 2}

			color := th.cyan
			if !canPlace {
				color = th.red
			}
			canvas.drawLine(rail.sysToWorld(origin).add(th.Vf2{1, 1}), rail.sysToWorld(p2).add(th.Vf2{1, 1}), 2, color)
		} else {
			if input.isJustPressed(input.mouse1) {
				hasOrigin = true
				origin = mp
			}
		}
	}
}
